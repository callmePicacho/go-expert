# 垃圾回收

所谓垃圾就是不再需要的内存块，这些垃圾如果不清理就没办法再次被分配使用

## 1. 垃圾回收算法

业界常见的垃圾回收算法有以下几种：

- 引用计数：对每个对象维护一个引用计数，当引用该对象的对象被销毁时，引用计数减 1，当引用计数器为0 时回收该对象
  - 优点：对象可以很快地被回收，不会出现内存耗尽或达到某个阀值时才回收
  - 缺点：不能很好地处理循环引用，而且实时维护引用计数，也有一定的代价
  - 代表语言：Python、PHP、Swift
- 标记—清除：从根变量开始遍历所有引用的对象，引用的对象标记为”被引用”，没有被标记的进行回收
  - 优点：解决了引用计数的缺点
  - 缺点：需要暂时停止程序运行
  - 代表语言：Go
- 分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率
  - 优点：回收性能好
  - 缺点：算法复杂
  - 代表语言：Java

## 2. Go 垃圾回收

### 1. 垃圾回收的原理

垃圾回收开始时从 root 对象进行递归扫描，将所有可达对象标记为 "被引用"，全部标记完后，只保留被标记的内存，其余内存回收

### 2. 内存标记

在 span 结构中，通过位图 allocBits 表示内存块分配情况，另一个位图 gcmarkBits 则用于标记内存块被引用情况

在标记阶段，对 gcmarkBits 中每块内存进行标记，有对象引用标记为 1，没有引用到的内存保持为 0（默认），当标记完成，使用 gcmarkBits 替换 allocBits

### 3. 三色标记

三色标记算法中将程序中的对象标记成黑、白和灰色三类，通过设置等待队列存放待标记对象：

- 灰色：对象还在标记队列中等待
- 黑色：对象已被标记，gcmarkBits 对应的位为1（该对象不会在本次GC中被清理）
- 白色：对象未被标记，gcmarkBits 对应的位为0（该对象将会在本次GC中被清理）

其具体步骤如下（BFS）：

1. 初始化 gcmarkBits
2. 开始 GC，从根对象开始扫描，先将根对象标记为"灰色"
3. 从等待队列中选择一个对象并将其标记为"黑色"
4. 从该"黑色"对象指向的所有对象都标记成"灰色"
5. 重复 2 3 步骤，直至对象中无灰色对象，此时黑色的就是存活对象，白色的就是可以回收的垃圾对象

### 4. STW

GC 过程中，如果由于内存引用关系变化将会导致错误回收内存，所以在 GC 时，需要停止所有 goroutine，专心做 GC，待 GC 结束后再恢复 goroutine

STW 会极大影响应用的执行

## 3. 垃圾回收优化

为了缩短STW的时间，Go 不断优化垃圾回收算法

### 1. 写屏障

写屏障能缩短 STW 时间

具体操作是在 GC 过程中对新分配的内存被立即标记，但缺点是 GC 过程中分配的内存不会在本轮 GC 中回收

### 2. 辅助 GC

为了防止内存分配过快，在 GC 过程中，如果 goroutine 需要分配内存，那么这个 goroutine 会参与一部分GC 的工作，即帮助 GC 做一部分工作

## 4. 垃圾回收触发时机

### 1. 内存分配量达到阈值

每次内存分配时都会检查当前内存分配量是否已达到阀值，如果达到阀值立即启动 GC

```text
阀值 = 上次GC内存分配量 * 内存增长率
```

内存增长率由环境变量 `GOGC` 控制，默认为 100，即每当内存扩大一倍时启动 GC

### 2. 定期触发

默认情况下，最长2分钟触发一次 GC

### 3. 手动触发

代码中可使用 `runtime.GC()` 手动触发 GC

## 5. GC 性能优化

GC 性能与对象数量负相关，对象越多 GC 性能越差，对程序影响越大

所以 GC 性能优化的思路之一就是减少对象分配个数，比如对象复用或使用大对象组合多个小对象等等